{% extends "base.html" %}
{% block title %}quiz · {{ quiz_page_title|default:quiz_title|lower }}{% endblock %}
{% block content %}
<style>
  .quiz-shell {
    display: grid;
    gap: var(--space-3);
  }

  .quiz-head {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: var(--space-3);
    flex-wrap: wrap;
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-3);
    background: linear-gradient(180deg, var(--surface-alt) 0%, var(--surface) 100%);
  }

  .quiz-headline {
    display: grid;
    gap: var(--space-2);
    max-width: 78ch;
  }

  .quiz-module {
    margin: 0;
    display: inline-flex;
    align-items: center;
    width: fit-content;
    min-height: 28px;
    border-radius: var(--radius-pill);
    border: 1px solid color-mix(in srgb, var(--accent) 34%, transparent);
    background: var(--info-bg);
    color: var(--info-ink);
    padding: 0 var(--space-2);
    font-size: 0.74rem;
    letter-spacing: 0.03em;
    text-transform: lowercase;
    font-weight: 800;
  }

  .quiz-title {
    margin: 0;
    font-size: clamp(1.28rem, 3vw, 2.05rem);
    line-height: 1.18;
    overflow-wrap: anywhere;
    text-transform: lowercase;
  }

  .quiz-login-note-links {
    display: inline-flex;
    gap: var(--space-2);
    flex-wrap: wrap;
  }

  .quiz-alert {
    margin-top: var(--space-3);
    border: 1px solid rgba(178, 59, 79, 0.4);
    border-radius: var(--radius-sub);
    padding: var(--space-3);
    background: var(--danger-bg-soft);
    color: var(--danger);
  }

  .quiz-loading {
    margin-top: var(--space-4);
    border: 1px solid var(--border);
    border-radius: var(--radius-sub);
    padding: var(--space-3);
    color: var(--muted);
    background: var(--surface-soft);
  }

  .quiz-stage {
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    background: var(--surface);
    padding: var(--space-4);
  }

  .quiz-flow-head {
    display: grid;
    gap: var(--space-2);
    margin-bottom: var(--space-3);
  }

  .quiz-flow-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: var(--space-2);
    align-items: baseline;
  }

  .quiz-counter {
    margin: 0;
    font-weight: 700;
  }

  .quiz-answered {
    margin: 0;
    color: var(--muted);
    font-size: 0.84rem;
    font-variant-numeric: tabular-nums;
  }

  .quiz-timer {
    margin: 0;
    font-size: 0.84rem;
    font-variant-numeric: tabular-nums;
    color: var(--warn-ink);
    font-weight: 700;
  }

  .quiz-progress-track {
    width: 100%;
    height: 9px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--progress-track-border);
    background: var(--info-bg);
    overflow: hidden;
    appearance: none;
  }

  .quiz-progress-track::-webkit-progress-bar {
    background: var(--info-bg);
  }

  .quiz-progress-track::-webkit-progress-value {
    background: linear-gradient(90deg, var(--progress-accent-start), var(--progress-accent-end));
  }

  .quiz-progress-track::-moz-progress-bar {
    background: linear-gradient(90deg, var(--progress-accent-start), var(--progress-accent-end));
  }

  .quiz-question {
    margin: 0 0 var(--space-3);
    font-size: clamp(1.08rem, 2.5vw, 1.42rem);
    line-height: 1.36;
  }

  .quiz-options {
    display: grid;
    gap: var(--space-2);
    margin-bottom: var(--space-3);
  }

  .quiz-option {
    text-align: left;
    display: flex;
    align-items: center;
    gap: var(--space-2);
    width: 100%;
    min-height: var(--control-min-height);
    border: 1px solid var(--border-strong);
    border-radius: var(--radius-sub);
    background: var(--surface-elevated);
    color: var(--ink);
    padding: var(--space-2) var(--space-3);
    cursor: pointer;
    transition: border-color 140ms ease, background 140ms ease, color 140ms ease;
  }

  .quiz-option:hover {
    border-color: color-mix(in srgb, var(--accent) 45%, transparent);
    background: var(--info-bg);
    color: var(--info-ink-strong);
  }

  .quiz-option.is-selected {
    border-color: color-mix(in srgb, var(--accent) 62%, transparent);
    background: var(--info-bg-strong);
  }

  .quiz-option.is-correct {
    border-color: rgba(31, 143, 78, 0.45);
    background: var(--success-bg-strong);
  }

  .quiz-option.is-wrong {
    border-color: rgba(178, 59, 79, 0.45);
    background: var(--danger-bg-soft);
  }

  .quiz-option-index {
    flex: 0 0 auto;
    width: 24px;
    height: 24px;
    border-radius: var(--radius-pill);
    border: 1px solid color-mix(in srgb, var(--accent) 36%, transparent);
    color: var(--info-ink);
    background: var(--info-bg);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.72rem;
    font-weight: 800;
  }

  .quiz-option-text {
    overflow-wrap: anywhere;
  }

  .quiz-hint,
  .quiz-rationale {
    border: 1px solid var(--border);
    border-radius: var(--radius-sub);
    padding: var(--space-3);
    margin: 0 0 var(--space-3);
  }

  .quiz-hint {
    color: var(--text-subtle-2);
    background: var(--info-bg);
  }

  .quiz-rationale {
    color: var(--text-subtle);
    background: var(--info-bg);
  }

  .quiz-points-feedback {
    border: 1px solid var(--border);
    border-radius: var(--radius-sub);
    padding: var(--space-2) var(--space-3);
    margin: 0 0 var(--space-3);
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    background: var(--surface-soft);
    color: var(--text-subtle);
  }

  .quiz-points-feedback.is-positive {
    border-color: rgba(31, 143, 78, 0.45);
    background: var(--success-bg-strong);
    color: var(--success-ink);
  }

  .quiz-points-feedback.is-neutral {
    border-color: var(--border);
    background: var(--surface-soft);
    color: var(--text-subtle);
  }

  .quiz-actions {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    align-items: center;
    justify-content: space-between;
  }

  .ghost-button {
    border: 1px solid var(--border-strong);
    border-radius: var(--radius-pill);
    background: var(--surface);
    color: var(--text-subtle-2);
    min-height: var(--control-min-height);
    padding: 0 var(--space-3);
    font-weight: 600;
    cursor: pointer;
    transition: border-color 140ms ease, background 140ms ease, color 140ms ease;
  }

  .ghost-button:hover {
    border-color: color-mix(in srgb, var(--accent) 40%, transparent);
    background: var(--accent-soft);
    color: var(--info-ink-strong);
  }

  .ghost-button[disabled] {
    opacity: 0.55;
    cursor: not-allowed;
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: var(--space-2);
    margin: var(--space-3) 0;
  }

  .summary-card {
    border: 1px solid var(--border);
    border-radius: var(--radius-sub);
    padding: var(--space-3);
    background: var(--surface-alt);
  }

  .summary-card strong {
    display: block;
    font-size: 1.28rem;
    margin-bottom: 0.1rem;
  }

  .quiz-login-prompt {
    margin-top: var(--space-4);
    border: 1px solid var(--warn-border);
    border-radius: var(--radius-md);
    padding: var(--space-3);
    background: var(--warn-bg);
    color: var(--warn-ink);
  }

  .quiz-login-prompt p {
    margin: 0 0 var(--space-2);
  }

  .quiz-cooldown-note {
    margin: 0;
    min-height: 1.2rem;
  }

  @media (max-width: 640px) {
    .summary-grid {
      grid-template-columns: 1fr;
    }

    .quiz-head {
      padding: var(--space-3);
    }
  }
</style>
<div class="card quiz-shell">
  <form class="inline-form is-hidden">{% csrf_token %}</form>
  <div class="quiz-head">
    <div class="quiz-headline">
      {% if quiz_module_label %}
      <p class="quiz-module">{{ quiz_module_label }}</p>
      {% endif %}
      <h1 class="quiz-title">{{ quiz_title }}</h1>
    </div>
    {% if user_is_authenticated %}
    <a class="ghost-link" href="{% url 'progress' %}">Tilbage til mit overblik</a>
    {% endif %}
  </div>

  <div id="quiz-error" class="quiz-alert is-hidden"></div>
  <div id="quiz-loading" class="quiz-loading">Indlæser quiz…</div>

  <section id="quiz-question-view" class="quiz-stage is-hidden">
    <div class="quiz-flow-head">
      <div class="quiz-flow-row">
        <p class="muted quiz-counter" id="quiz-counter"></p>
        <p class="quiz-answered" id="quiz-answered"></p>
        <p class="quiz-timer" id="quiz-timer"></p>
      </div>
      <progress
        id="quiz-progress"
        class="quiz-progress-track"
        value="0"
        max="100"
        aria-label="Progress i quiz"
      >
        0%
      </progress>
    </div>
    <h2 class="quiz-question" id="quiz-question"></h2>
    <div id="quiz-hint" class="quiz-hint is-hidden"></div>
    <div id="quiz-options" class="quiz-options"></div>
    <div id="quiz-rationale" class="quiz-rationale is-hidden"></div>
    <p id="quiz-points-feedback" class="quiz-points-feedback is-hidden" aria-live="polite"></p>
    <div class="quiz-actions">
      <button id="quiz-back" class="ghost-button" type="button">Forrige</button>
      <button id="quiz-hint-btn" class="ghost-button" type="button">Vis hint</button>
      <button id="quiz-next" class="btn-primary" type="button">Næste</button>
    </div>
  </section>

  <section id="quiz-summary-view" class="quiz-stage is-hidden">
    <h2 class="quiz-question">opsummering</h2>
    <p class="muted" id="quiz-summary-line"></p>
    <p class="quiz-cooldown-note muted" id="quiz-cooldown-note"></p>
    <div class="summary-grid">
      <div class="summary-card">
        <strong id="summary-correct">0</strong>
        Korrekte svar
      </div>
      <div class="summary-card">
        <strong id="summary-wrong">0</strong>
        Forkerte svar
      </div>
      <div class="summary-card">
        <strong id="summary-skipped">0</strong>
        Ubesvarede
      </div>
      <div class="summary-card">
        <strong id="summary-answered">0 / 0</strong>
        Besvaret
      </div>
    </div>
    <div class="quiz-actions">
      <button id="quiz-review" class="ghost-button" type="button">Gennemgå svar</button>
      <button id="quiz-reset" class="ghost-button" type="button">Tag quiz igen</button>
    </div>
  </section>

  {% if not user_is_authenticated %}
  <div id="login-end-prompt" class="quiz-login-prompt is-hidden">
    <p>Quizzen er færdig. Log ind nu for at gemme din score og se din samlede score.</p>
    <span class="quiz-login-note-links">
      <a class="nav-action" href="{{ login_next_url }}">Log ind</a>
      <a class="nav-action" href="{{ signup_next_url }}">Opret konto</a>
    </span>
  </div>
  {% endif %}
</div>

<script>
  (function () {
    "use strict";

    const quizContentUrl = "{{ quiz_content_url }}";
    const stateApiUrl = "{{ state_api_url }}";
    const questionTimeLimitSeconds = Math.max(
      5,
      Number.parseInt("{{ question_time_limit_seconds|default:30 }}", 10) || 30
    );
    const cooldownResetSeconds = 3600;
    const isAuthenticated = {{ user_is_authenticated|yesno:"true,false" }};
    const localStateKey = "quiz-local-state:{{ quiz_id }}";
    const localCooldownKey = "quiz-local-cooldown:{{ quiz_id }}";
    const loginEndPrompt = document.getElementById("login-end-prompt");

    const loadingNode = document.getElementById("quiz-loading");
    const errorNode = document.getElementById("quiz-error");
    const questionViewNode = document.getElementById("quiz-question-view");
    const summaryViewNode = document.getElementById("quiz-summary-view");

    const counterNode = document.getElementById("quiz-counter");
    const answeredNode = document.getElementById("quiz-answered");
    const timerNode = document.getElementById("quiz-timer");
    const progressNode = document.getElementById("quiz-progress");
    const questionNode = document.getElementById("quiz-question");
    const hintNode = document.getElementById("quiz-hint");
    const hintBtnNode = document.getElementById("quiz-hint-btn");
    const optionsNode = document.getElementById("quiz-options");
    const rationaleNode = document.getElementById("quiz-rationale");
    const pointsFeedbackNode = document.getElementById("quiz-points-feedback");

    const backBtnNode = document.getElementById("quiz-back");
    const nextBtnNode = document.getElementById("quiz-next");
    const reviewBtnNode = document.getElementById("quiz-review");
    const resetBtnNode = document.getElementById("quiz-reset");

    const summaryLineNode = document.getElementById("quiz-summary-line");
    const summaryCorrectNode = document.getElementById("summary-correct");
    const summaryWrongNode = document.getElementById("summary-wrong");
    const summarySkippedNode = document.getElementById("summary-skipped");
    const summaryAnsweredNode = document.getElementById("summary-answered");
    const summaryCooldownNode = document.getElementById("quiz-cooldown-note");

    let quiz = null;
    let tickerId = null;
    let timerBusy = false;
    let cooldownState = null;
    let state = {
      userAnswers: {},
      currentQuestionIndex: 0,
      hiddenQuestionIndices: [],
      currentView: "question",
      timedOutQuestionIndices: [],
      questionDeadlineEpochMs: {},
      questionResponseDurationMs: {},
      showHintForCurrent: false,
    };

    function getCsrfToken() {
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (const cookie of cookies) {
        const entry = cookie.trim();
        if (entry.startsWith("csrftoken=")) {
          return decodeURIComponent(entry.slice("csrftoken=".length));
        }
      }
      return "";
    }

    function showError(message) {
      errorNode.textContent = message;
      errorNode.classList.remove("is-hidden");
    }

    function hideError() {
      errorNode.textContent = "";
      errorNode.classList.add("is-hidden");
    }

    function hideLoading() {
      loadingNode.classList.add("is-hidden");
    }

    function parseStoredState(rawValue) {
      if (!rawValue) {
        return null;
      }
      if (typeof rawValue === "object") {
        return rawValue;
      }
      if (typeof rawValue !== "string") {
        return null;
      }
      try {
        return JSON.parse(rawValue);
      } catch (error) {
        return null;
      }
    }

    function loadLocalState() {
      try {
        return parseStoredState(window.localStorage.getItem(localStateKey));
      } catch (error) {
        return null;
      }
    }

    function saveLocalState(payload) {
      try {
        window.localStorage.setItem(localStateKey, JSON.stringify(payload));
      } catch (error) {
        // Local storage can fail in restricted browser modes.
      }
    }

    function clearLocalState() {
      try {
        window.localStorage.removeItem(localStateKey);
      } catch (error) {
        // Ignore local storage failures.
      }
    }

    function parseEpoch(value) {
      const parsed = Number.parseInt(String(value), 10);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        return null;
      }
      return parsed;
    }

    function loadLocalCooldown() {
      try {
        return parseStoredState(window.localStorage.getItem(localCooldownKey));
      } catch (error) {
        return null;
      }
    }

    function saveLocalCooldown(payload) {
      try {
        window.localStorage.setItem(localCooldownKey, JSON.stringify(payload));
      } catch (error) {
        // Ignore local storage failures.
      }
    }

    function clearLocalCooldown() {
      try {
        window.localStorage.removeItem(localCooldownKey);
      } catch (error) {
        // Ignore local storage failures.
      }
    }

    function normalizeQuizPayload(payload) {
      if (!payload || typeof payload !== "object") {
        return null;
      }
      const questions = Array.isArray(payload.questions) ? payload.questions : [];
      if (!questions.length) {
        return null;
      }
      return {
        title: typeof payload.title === "string" && payload.title.trim() ? payload.title.trim() : "Quiz",
        questions,
      };
    }

    function normalizeStatePayload(rawState) {
      const questionCount = quiz.questions.length;
      const normalized = {
        userAnswers: {},
        currentQuestionIndex: 0,
        hiddenQuestionIndices: [],
        currentView: "question",
        timedOutQuestionIndices: [],
        questionDeadlineEpochMs: {},
        questionResponseDurationMs: {},
        showHintForCurrent: false,
      };

      if (!rawState || typeof rawState !== "object") {
        return normalized;
      }

      if (rawState.userAnswers && typeof rawState.userAnswers === "object") {
        for (const [rawKey, rawValue] of Object.entries(rawState.userAnswers)) {
          const index = Number.parseInt(String(rawKey), 10);
          if (!Number.isInteger(index) || index < 0 || index >= questionCount) {
            continue;
          }
          if (rawValue === null) {
            normalized.userAnswers[String(index)] = null;
            continue;
          }
          if (!Number.isInteger(rawValue)) {
            continue;
          }
          const options = quiz.questions[index]?.answerOptions;
          if (!Array.isArray(options) || rawValue < 0 || rawValue >= options.length) {
            continue;
          }
          normalized.userAnswers[String(index)] = rawValue;
        }
      }

      const indexValue = Number.parseInt(String(rawState.currentQuestionIndex ?? 0), 10);
      if (Number.isInteger(indexValue) && indexValue >= 0 && indexValue < questionCount) {
        normalized.currentQuestionIndex = indexValue;
      }

      if (Array.isArray(rawState.hiddenQuestionIndices)) {
        normalized.hiddenQuestionIndices = rawState.hiddenQuestionIndices
          .map((entry) => Number.parseInt(String(entry), 10))
          .filter((entry) => Number.isInteger(entry) && entry >= 0 && entry < questionCount);
      }

      if (String(rawState.currentView || "").toLowerCase() === "summary") {
        normalized.currentView = "summary";
      }

      if (Array.isArray(rawState.timedOutQuestionIndices)) {
        const timedOut = rawState.timedOutQuestionIndices
          .map((entry) => Number.parseInt(String(entry), 10))
          .filter((entry) => Number.isInteger(entry) && entry >= 0 && entry < questionCount);
        normalized.timedOutQuestionIndices = Array.from(new Set(timedOut));
      }

      if (rawState.questionDeadlineEpochMs && typeof rawState.questionDeadlineEpochMs === "object") {
        for (const [rawKey, rawValue] of Object.entries(rawState.questionDeadlineEpochMs)) {
          const index = Number.parseInt(String(rawKey), 10);
          if (!Number.isInteger(index) || index < 0 || index >= questionCount) {
            continue;
          }
          const deadline = parseEpoch(rawValue);
          if (deadline) {
            normalized.questionDeadlineEpochMs[String(index)] = deadline;
          }
        }
      }

      if (rawState.questionResponseDurationMs && typeof rawState.questionResponseDurationMs === "object") {
        for (const [rawKey, rawValue] of Object.entries(rawState.questionResponseDurationMs)) {
          const index = Number.parseInt(String(rawKey), 10);
          if (!Number.isInteger(index) || index < 0 || index >= questionCount) {
            continue;
          }
          const duration = Number.parseInt(String(rawValue), 10);
          if (!Number.isFinite(duration) || duration <= 0) {
            continue;
          }
          normalized.questionResponseDurationMs[String(index)] = Math.max(1_000, duration);
        }
      }

      return normalized;
    }

    function normalizeCooldownPayload(rawValue) {
      if (!rawValue || typeof rawValue !== "object") {
        return null;
      }
      const isBlocked = Boolean(rawValue.is_blocked);
      const retryAfterSeconds = Math.max(0, Number.parseInt(String(rawValue.retry_after_seconds ?? 0), 10) || 0);
      const streakCount = Math.max(0, Number.parseInt(String(rawValue.streak_count ?? 0), 10) || 0);
      const nextCooldownSeconds = Math.max(
        60,
        Number.parseInt(String(rawValue.next_cooldown_seconds ?? 60), 10) || 60
      );
      const availableAt = typeof rawValue.available_at === "string" && rawValue.available_at.trim()
        ? rawValue.available_at.trim()
        : null;
      return {
        is_blocked: isBlocked,
        retry_after_seconds: retryAfterSeconds,
        streak_count: streakCount,
        next_cooldown_seconds: nextCooldownSeconds,
        available_at: availableAt,
      };
    }

    function cooldownSecondsForStreak(streakCount) {
      const streak = Math.max(1, Number.parseInt(String(streakCount), 10) || 1);
      if (streak <= 2) {
        return 60;
      }
      if (streak <= 5) {
        return 300;
      }
      return 600;
    }

    function formatSeconds(seconds) {
      const value = Math.max(0, Number.parseInt(String(seconds), 10) || 0);
      const minutes = Math.floor(value / 60);
      const rest = value % 60;
      if (minutes <= 0) {
        return `${rest}s`;
      }
      return `${minutes}m ${rest}s`;
    }

    function liveCooldownState(rawCooldown) {
      const normalized = normalizeCooldownPayload(rawCooldown);
      if (!normalized) {
        return null;
      }
      if (!normalized.available_at) {
        return normalized;
      }
      const availableEpoch = Date.parse(normalized.available_at);
      if (!Number.isFinite(availableEpoch)) {
        return normalized;
      }
      const diffSeconds = Math.max(0, Math.ceil((availableEpoch - Date.now()) / 1000));
      return {
        ...normalized,
        is_blocked: diffSeconds > 0,
        retry_after_seconds: diffSeconds,
      };
    }

    function refreshAnonymousCooldown() {
      const stored = loadLocalCooldown();
      if (!stored || typeof stored !== "object") {
        return normalizeCooldownPayload({
          is_blocked: false,
          retry_after_seconds: 0,
          streak_count: 0,
          next_cooldown_seconds: 60,
          available_at: null,
        });
      }

      let streakCount = Math.max(0, Number.parseInt(String(stored.streak_count ?? 0), 10) || 0);
      const availableEpoch = parseEpoch(stored.available_epoch_ms);
      const lastCompletedEpoch = parseEpoch(stored.last_completed_epoch_ms);
      const now = Date.now();
      if (lastCompletedEpoch && now - lastCompletedEpoch >= cooldownResetSeconds * 1000) {
        clearLocalCooldown();
        return normalizeCooldownPayload({
          is_blocked: false,
          retry_after_seconds: 0,
          streak_count: 0,
          next_cooldown_seconds: 60,
          available_at: null,
        });
      }

      const retryAfterSeconds = availableEpoch ? Math.max(0, Math.ceil((availableEpoch - now) / 1000)) : 0;
      return normalizeCooldownPayload({
        is_blocked: retryAfterSeconds > 0,
        retry_after_seconds: retryAfterSeconds,
        streak_count: streakCount,
        next_cooldown_seconds: cooldownSecondsForStreak(streakCount + 1),
        available_at: availableEpoch ? new Date(availableEpoch).toISOString() : null,
      });
    }

    function registerAnonymousCompletion() {
      const now = Date.now();
      const current = refreshAnonymousCooldown();
      const streakCount = Math.max(0, Number.parseInt(String(current?.streak_count ?? 0), 10) || 0) + 1;
      const cooldownSeconds = cooldownSecondsForStreak(streakCount);
      const availableEpoch = now + cooldownSeconds * 1000;
      saveLocalCooldown({
        streak_count: streakCount,
        last_completed_epoch_ms: now,
        available_epoch_ms: availableEpoch,
      });
      cooldownState = normalizeCooldownPayload({
        is_blocked: true,
        retry_after_seconds: cooldownSeconds,
        streak_count: streakCount,
        next_cooldown_seconds: cooldownSecondsForStreak(streakCount + 1),
        available_at: new Date(availableEpoch).toISOString(),
      });
    }

    function answeredCount() {
      const answered = Object.entries(state.userAnswers)
        .filter(([, value]) => value !== null && value !== undefined)
        .map(([key]) => key);
      const timedOut = (Array.isArray(state.timedOutQuestionIndices) ? state.timedOutQuestionIndices : [])
        .map((index) => String(index));
      return new Set([...answered, ...timedOut]).size;
    }

    function summaryStats() {
      const timedOut = new Set(
        (Array.isArray(state.timedOutQuestionIndices) ? state.timedOutQuestionIndices : []).map((index) => String(index))
      );
      let correct = 0;
      let wrong = 0;
      let skipped = 0;
      quiz.questions.forEach((question, index) => {
        if (timedOut.has(String(index))) {
          wrong += 1;
          return;
        }
        const selected = state.userAnswers[String(index)];
        if (selected === null || selected === undefined) {
          skipped += 1;
          return;
        }
        const option = Array.isArray(question.answerOptions) ? question.answerOptions[selected] : null;
        if (option && option.isCorrect === true) {
          correct += 1;
        } else {
          wrong += 1;
        }
      });
      return { correct, wrong, skipped };
    }

    function isQuestionTimedOut(index) {
      const value = Number.parseInt(String(index), 10);
      if (!Number.isInteger(value)) {
        return false;
      }
      return (state.timedOutQuestionIndices || []).includes(value);
    }

    function addTimedOutQuestion(index) {
      const value = Number.parseInt(String(index), 10);
      if (!Number.isInteger(value)) {
        return;
      }
      if (!Array.isArray(state.timedOutQuestionIndices)) {
        state.timedOutQuestionIndices = [];
      }
      if (!state.timedOutQuestionIndices.includes(value)) {
        state.timedOutQuestionIndices.push(value);
      }
    }

    function ensureDeadlineForQuestion(index) {
      const key = String(index);
      const selected = state.userAnswers[key];
      if (selected !== null && selected !== undefined) {
        return;
      }
      if (isQuestionTimedOut(index)) {
        return;
      }
      if (!state.questionDeadlineEpochMs || typeof state.questionDeadlineEpochMs !== "object") {
        state.questionDeadlineEpochMs = {};
      }
      const existing = parseEpoch(state.questionDeadlineEpochMs[key]);
      if (existing && existing > Date.now()) {
        return;
      }
      state.questionDeadlineEpochMs[key] = Date.now() + questionTimeLimitSeconds * 1000;
    }

    function elapsedMsFromQuestionDeadline(index) {
      const key = String(index);
      const deadline = parseEpoch(state.questionDeadlineEpochMs?.[key]);
      if (!deadline) {
        return questionTimeLimitSeconds * 1000;
      }
      const maxDurationMs = questionTimeLimitSeconds * 1000;
      const remainingMs = Math.max(0, deadline - Date.now());
      const elapsedMs = maxDurationMs - Math.min(maxDurationMs, remainingMs);
      return Math.max(1_000, Math.round(elapsedMs));
    }

    function setQuestionResponseDuration(index, durationMs) {
      const key = String(index);
      const normalizedDuration = Math.max(
        1_000,
        Number.parseInt(String(durationMs), 10) || questionTimeLimitSeconds * 1000
      );
      if (!state.questionResponseDurationMs || typeof state.questionResponseDurationMs !== "object") {
        state.questionResponseDurationMs = {};
      }
      if (parseEpoch(state.questionResponseDurationMs[key])) {
        return;
      }
      state.questionResponseDurationMs[key] = normalizedDuration;
    }

    function responseDurationMsForQuestion(index) {
      const key = String(index);
      const duration = parseEpoch(state.questionResponseDurationMs?.[key]);
      if (duration) {
        return Math.max(1_000, duration);
      }
      return questionTimeLimitSeconds * 1000;
    }

    function computeQuestionPoints(isCorrect, durationMs) {
      if (!isCorrect) {
        return 0;
      }
      const duration = Math.max(1_000, Number.parseInt(String(durationMs), 10) || questionTimeLimitSeconds * 1000);
      const expectedMs = questionTimeLimitSeconds * 1000;
      const speedFactor = Math.max(0.0, Math.min(1.0, expectedMs / duration));
      const speedBonus = Math.round(20 * speedFactor);
      return 100 + speedBonus;
    }

    function formatDurationLabel(durationMs) {
      const value = Math.max(0, Number.parseInt(String(durationMs), 10) || 0);
      const seconds = value / 1000;
      if (seconds >= 10) {
        return `${Math.round(seconds)}s`;
      }
      return `${seconds.toFixed(1).replace(".", ",")}s`;
    }

    function hideQuestionPointsFeedback() {
      if (!pointsFeedbackNode) {
        return;
      }
      pointsFeedbackNode.textContent = "";
      pointsFeedbackNode.classList.add("is-hidden");
      pointsFeedbackNode.classList.remove("is-positive");
      pointsFeedbackNode.classList.remove("is-neutral");
    }

    function showQuestionPointsFeedback(message, toneClass) {
      if (!pointsFeedbackNode) {
        return;
      }
      pointsFeedbackNode.textContent = message;
      pointsFeedbackNode.classList.remove("is-hidden");
      pointsFeedbackNode.classList.remove("is-positive");
      pointsFeedbackNode.classList.remove("is-neutral");
      if (toneClass) {
        pointsFeedbackNode.classList.add(toneClass);
      }
    }

    function renderQuestionPointsFeedback({ options, selectedOption, hasAnswered, isTimedOut }) {
      if (!hasAnswered && !isTimedOut) {
        hideQuestionPointsFeedback();
        return;
      }
      const durationMs = responseDurationMsForQuestion(state.currentQuestionIndex);
      const durationLabel = formatDurationLabel(durationMs);
      if (isTimedOut) {
        showQuestionPointsFeedback(`0 point · tid udløb efter ${durationLabel}.`, "is-neutral");
        return;
      }
      const selected = options[selectedOption];
      const isCorrect = Boolean(selected && selected.isCorrect === true);
      const points = computeQuestionPoints(isCorrect, durationMs);
      if (isCorrect) {
        showQuestionPointsFeedback(`+${points} point · svar på ${durationLabel}.`, "is-positive");
      } else {
        showQuestionPointsFeedback(`0 point · svar på ${durationLabel}.`, "is-neutral");
      }
    }

    function renderTimerLabel() {
      if (!timerNode) {
        return;
      }
      if (!quiz || state.currentView !== "question") {
        timerNode.textContent = "";
        return;
      }
      const key = String(state.currentQuestionIndex);
      if (isQuestionTimedOut(state.currentQuestionIndex)) {
        timerNode.textContent = "Tid: udløbet";
        return;
      }
      const selected = state.userAnswers[key];
      if (selected !== null && selected !== undefined) {
        timerNode.textContent = "Tid: besvaret";
        return;
      }
      const deadline = parseEpoch(state.questionDeadlineEpochMs?.[key]);
      if (!deadline) {
        timerNode.textContent = `Tid: ${questionTimeLimitSeconds}s`;
        return;
      }
      const remaining = Math.max(0, Math.ceil((deadline - Date.now()) / 1000));
      timerNode.textContent = `Tid: ${remaining}s`;
    }

    function activeCooldownState() {
      if (isAuthenticated) {
        return liveCooldownState(cooldownState);
      }
      return refreshAnonymousCooldown();
    }

    function updateCooldownUi() {
      const active = activeCooldownState();
      cooldownState = active;

      const shouldBlock = Boolean(active && active.is_blocked);
      resetBtnNode.disabled = shouldBlock;
      if (!summaryCooldownNode) {
        return;
      }
      if (shouldBlock) {
        summaryCooldownNode.textContent = `Du kan tage quizzen igen om ${formatSeconds(
          active.retry_after_seconds
        )}.`;
        return;
      }
      summaryCooldownNode.textContent = "";
    }

    function showEndPromptIfNeeded() {
      if (!loginEndPrompt || isAuthenticated) {
        return;
      }
      if (state.currentView === "summary") {
        loginEndPrompt.classList.remove("is-hidden");
      } else {
        loginEndPrompt.classList.add("is-hidden");
      }
    }

    async function fetchQuiz() {
      const response = await fetch(quizContentUrl, { credentials: "same-origin" });
      if (!response.ok) {
        throw new Error("Kunne ikke hente quiz-indhold.");
      }
      const payload = await response.json();
      const normalized = normalizeQuizPayload(payload);
      if (!normalized) {
        throw new Error("Quiz-indholdet er ugyldigt eller tomt.");
      }
      return normalized;
    }

    async function fetchAccountState() {
      if (!isAuthenticated) {
        return null;
      }
      const response = await fetch(stateApiUrl, { credentials: "same-origin" });
      if (!response.ok) {
        throw new Error("Kunne ikke hente gemt quiz-state.");
      }
      return response.json();
    }

    function currentQuestion() {
      return quiz.questions[state.currentQuestionIndex];
    }

    async function handleQuestionTimeoutIfNeeded() {
      if (!quiz || state.currentView !== "question" || timerBusy) {
        return;
      }
      const key = String(state.currentQuestionIndex);
      if (isQuestionTimedOut(state.currentQuestionIndex)) {
        return;
      }
      const selected = state.userAnswers[key];
      if (selected !== null && selected !== undefined) {
        return;
      }
      const deadline = parseEpoch(state.questionDeadlineEpochMs?.[key]);
      if (!deadline || deadline > Date.now()) {
        return;
      }

      timerBusy = true;
      addTimedOutQuestion(state.currentQuestionIndex);
      state.userAnswers[key] = null;
      setQuestionResponseDuration(state.currentQuestionIndex, questionTimeLimitSeconds * 1000);
      delete state.questionDeadlineEpochMs[key];
      state.showHintForCurrent = false;

      if (state.currentQuestionIndex >= quiz.questions.length - 1) {
        state.currentView = "summary";
        if (!isAuthenticated) {
          registerAnonymousCompletion();
        }
      } else {
        state.currentQuestionIndex += 1;
      }

      try {
        await saveState();
      } catch (error) {
        showError("Kunne ikke gemme timeout-state. Prøv igen.");
      } finally {
        render();
        timerBusy = false;
      }
    }

    function startTicker() {
      if (tickerId !== null) {
        return;
      }
      tickerId = window.setInterval(function () {
        if (!quiz) {
          return;
        }
        if (state.currentView === "question") {
          renderTimerLabel();
          handleQuestionTimeoutIfNeeded().catch(() => {
            showError("Kunne ikke håndtere timeout. Prøv igen.");
          });
        } else {
          updateCooldownUi();
        }
      }, 250);
    }

    function renderQuestionView() {
      const question = currentQuestion();
      const options = Array.isArray(question.answerOptions) ? question.answerOptions : [];
      const selectedOption = state.userAnswers[String(state.currentQuestionIndex)];
      const hasAnswered = selectedOption !== null && selectedOption !== undefined;
      const isTimedOut = isQuestionTimedOut(state.currentQuestionIndex);
      const totalQuestions = quiz.questions.length;
      const answeredQuestions = answeredCount();
      const flowProgress = totalQuestions ? Math.round(((state.currentQuestionIndex + 1) / totalQuestions) * 100) : 0;

      ensureDeadlineForQuestion(state.currentQuestionIndex);

      counterNode.textContent = `Spørgsmål ${state.currentQuestionIndex + 1} af ${totalQuestions}`;
      answeredNode.textContent = `Besvaret: ${answeredQuestions} / ${totalQuestions}`;
      progressNode.value = flowProgress;
      progressNode.textContent = `${flowProgress}%`;
      questionNode.textContent = String(question.question || "");

      optionsNode.innerHTML = "";
      options.forEach((option, optionIndex) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "quiz-option";
        const optionLabel = document.createElement("span");
        optionLabel.className = "quiz-option-index";
        optionLabel.textContent = String.fromCharCode(65 + optionIndex);

        const optionText = document.createElement("span");
        optionText.className = "quiz-option-text";
        optionText.textContent = String(option?.text || "");
        button.append(optionLabel, optionText);
        button.disabled = isTimedOut;
        if (selectedOption === optionIndex) {
          button.classList.add("is-selected");
          if (option?.isCorrect === true) {
            button.classList.add("is-correct");
          } else {
            button.classList.add("is-wrong");
          }
        } else if (hasAnswered && option?.isCorrect === true) {
          button.classList.add("is-correct");
        }
        button.addEventListener("click", function () {
          if (isTimedOut) {
            return;
          }
          setQuestionResponseDuration(state.currentQuestionIndex, elapsedMsFromQuestionDeadline(state.currentQuestionIndex));
          state.userAnswers[String(state.currentQuestionIndex)] = optionIndex;
          state.timedOutQuestionIndices = (state.timedOutQuestionIndices || []).filter(
            (value) => value !== state.currentQuestionIndex
          );
          delete state.questionDeadlineEpochMs[String(state.currentQuestionIndex)];
          state.showHintForCurrent = false;
          saveState().catch((error) => {
            showError("Kunne ikke gemme state. Prøv igen.");
          });
          render();
        });
        optionsNode.appendChild(button);
      });

      const hintText = String(question.hint || "").trim();
      if (hintText) {
        hintBtnNode.disabled = false;
        hintBtnNode.textContent = state.showHintForCurrent ? "Skjul hint" : "Vis hint";
        if (state.showHintForCurrent) {
          hintNode.textContent = hintText;
          hintNode.classList.remove("is-hidden");
        } else {
          hintNode.textContent = "";
          hintNode.classList.add("is-hidden");
        }
      } else {
        hintBtnNode.disabled = true;
        hintBtnNode.textContent = "Ingen hint";
        hintNode.textContent = "";
        hintNode.classList.add("is-hidden");
      }

      if (isTimedOut) {
        rationaleNode.textContent = "Tiden udløb for dette spørgsmål, og svaret tæller som forkert.";
        rationaleNode.classList.remove("is-hidden");
      } else if (hasAnswered) {
        const selected = options[selectedOption];
        const rationale = String(selected?.rationale || "").trim();
        if (rationale) {
          rationaleNode.textContent = rationale;
          rationaleNode.classList.remove("is-hidden");
        } else {
          rationaleNode.textContent = "";
          rationaleNode.classList.add("is-hidden");
        }
      } else {
        rationaleNode.textContent = "";
        rationaleNode.classList.add("is-hidden");
      }
      renderQuestionPointsFeedback({
        options,
        selectedOption,
        hasAnswered,
        isTimedOut,
      });

      backBtnNode.disabled = state.currentQuestionIndex === 0;
      nextBtnNode.textContent =
        state.currentQuestionIndex >= quiz.questions.length - 1 ? "Se opsummering" : "Næste";
      renderTimerLabel();
    }

    function renderSummaryView() {
      const stats = summaryStats();
      const total = quiz.questions.length;
      summaryLineNode.textContent = `Du svarede ${stats.correct} korrekt ud af ${total}.`;
      summaryCorrectNode.textContent = String(stats.correct);
      summaryWrongNode.textContent = String(stats.wrong);
      summarySkippedNode.textContent = String(stats.skipped);
      summaryAnsweredNode.textContent = `${answeredCount()} / ${total}`;
      updateCooldownUi();
    }

    function render() {
      hideError();
      hideLoading();

      if (state.currentView === "summary") {
        questionViewNode.classList.add("is-hidden");
        summaryViewNode.classList.remove("is-hidden");
        renderSummaryView();
      } else {
        summaryViewNode.classList.add("is-hidden");
        questionViewNode.classList.remove("is-hidden");
        renderQuestionView();
      }
      showEndPromptIfNeeded();
    }

    async function saveState() {
      const payload = {
        userAnswers: state.userAnswers,
        currentQuestionIndex: state.currentQuestionIndex,
        hiddenQuestionIndices: state.hiddenQuestionIndices,
        currentView: state.currentView,
        timedOutQuestionIndices: state.timedOutQuestionIndices,
        questionDeadlineEpochMs: state.questionDeadlineEpochMs,
        questionResponseDurationMs: state.questionResponseDurationMs,
      };

      saveLocalState(payload);

      const accountPayload = {
        userAnswers: payload.userAnswers,
        currentQuestionIndex: payload.currentQuestionIndex,
        hiddenQuestionIndices: payload.hiddenQuestionIndices,
        currentView: payload.currentView,
        timedOutQuestionIndices: payload.timedOutQuestionIndices,
        questionDeadlineEpochMs: payload.questionDeadlineEpochMs,
      };

      if (!isAuthenticated) {
        cooldownState = activeCooldownState();
        return { ok: true, cooldown: cooldownState };
      }

      const response = await fetch(stateApiUrl, {
        method: "POST",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": getCsrfToken(),
        },
        body: JSON.stringify(accountPayload),
      });
      if (response.status === 429) {
        let body = null;
        try {
          body = await response.json();
        } catch (error) {
          body = null;
        }
        cooldownState = normalizeCooldownPayload(body?.cooldown);
        return { ok: false, cooldown: cooldownState };
      }
      if (!response.ok) {
        throw new Error("Failed to save state");
      }
      const body = await response.json();
      cooldownState = normalizeCooldownPayload(body?.cooldown);
      return { ok: true, cooldown: cooldownState, data: body };
    }

    async function init() {
      try {
        quiz = await fetchQuiz();
      } catch (error) {
        hideLoading();
        showError("Quizzen kunne ikke indlæses.");
        return;
      }

      const localState = loadLocalState();
      const normalizedLocalState = normalizeStatePayload(localState);
      try {
        const accountState = await fetchAccountState();
        cooldownState = normalizeCooldownPayload(accountState?._meta?.cooldown);
        state = normalizeStatePayload(accountState || localState);
        if (accountState && normalizedLocalState.questionResponseDurationMs) {
          state.questionResponseDurationMs = normalizedLocalState.questionResponseDurationMs;
        }
        render();

        if (isAuthenticated && localState && !accountState) {
          await saveState();
          clearLocalState();
        }
      } catch (error) {
        state = normalizeStatePayload(localState);
        if (!isAuthenticated) {
          cooldownState = refreshAnonymousCooldown();
        }
        render();
        if (isAuthenticated) {
          showError("Kunne ikke hente kontostate. Viser lokal state i stedet.");
        }
      }
      if (!isAuthenticated && !cooldownState) {
        cooldownState = refreshAnonymousCooldown();
      }
      startTicker();
    }

    hintBtnNode.addEventListener("click", function () {
      state.showHintForCurrent = !state.showHintForCurrent;
      render();
    });

    backBtnNode.addEventListener("click", function () {
      if (state.currentView === "summary") {
        state.currentView = "question";
        state.currentQuestionIndex = Math.max(quiz.questions.length - 1, 0);
      } else if (state.currentQuestionIndex > 0) {
        state.currentQuestionIndex -= 1;
      }
      state.showHintForCurrent = false;
      ensureDeadlineForQuestion(state.currentQuestionIndex);
      saveState().catch(() => {
        showError("Kunne ikke gemme state. Prøv igen.");
      });
      render();
    });

    nextBtnNode.addEventListener("click", function () {
      if (state.currentQuestionIndex >= quiz.questions.length - 1) {
        state.currentView = "summary";
        if (!isAuthenticated) {
          registerAnonymousCompletion();
        }
      } else {
        state.currentQuestionIndex += 1;
        ensureDeadlineForQuestion(state.currentQuestionIndex);
      }
      state.showHintForCurrent = false;
      saveState().catch(() => {
        showError("Kunne ikke gemme state. Prøv igen.");
      });
      render();
    });

    reviewBtnNode.addEventListener("click", function () {
      state.currentView = "question";
      state.currentQuestionIndex = 0;
      state.showHintForCurrent = false;
      ensureDeadlineForQuestion(state.currentQuestionIndex);
      saveState().catch(() => {
        showError("Kunne ikke gemme state. Prøv igen.");
      });
      render();
    });

    resetBtnNode.addEventListener("click", async function () {
      const active = activeCooldownState();
      if (active && active.is_blocked) {
        showError(`Du kan tage quizzen igen om ${formatSeconds(active.retry_after_seconds)}.`);
        render();
        return;
      }

      const previousState = state;
      state = normalizeStatePayload(null);
      ensureDeadlineForQuestion(state.currentQuestionIndex);

      try {
        const result = await saveState();
        if (result && result.ok === false) {
          state = previousState;
          const blocked = activeCooldownState();
          if (blocked && blocked.is_blocked) {
            showError(`Du kan tage quizzen igen om ${formatSeconds(blocked.retry_after_seconds)}.`);
          } else {
            showError("Du kan ikke starte quizzen igen endnu.");
          }
        }
      } catch (error) {
        state = previousState;
        showError("Kunne ikke nulstille state. Prøv igen.");
      }
      render();
    });

    init();
  })();
</script>
{% endblock %}
